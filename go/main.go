package main

import (
	  "crypto/sha256"
    "crypto/x509"
    "encoding/hex"
    "encoding/json"
    "encoding/pem"
    "fmt"
    "github.com/google/uuid"
    "github.com/square/go-jose"
    "io/ioutil"
    "os"
    "time"
)

type TokenPayload struct {
    Jti         string `json:"jti"`
    Issuer      string `json:"iss"`
    Audience    string `json:"aud"`
    IssuedAt    int64  `json:"iat"`
    ExpiresAt   int64  `json:"exp"`
    Subject     string `json:"sub"`
    GivenName   string `json:"given_name"`
    FamilyName  string `json:"family_name"`
    Email       string `json:"email"`
    PhoneNumber string `json:"phone_number"`
    Locale      string `json:"locale"`
}

func main() {
    // Read your keys generated by openssl
    privateKey, err := readPrivateKey("../keys/private.pem")
    exitOnError(err, "failed to read private key")

    publicKey, keyHash, err := readPublicKey("../keys/public.pem")
    exitOnError(err, "failed to read public key")

    jwk := &jose.JSONWebKey{
        Key: publicKey,
        KeyID: keyHash,
        Algorithm: "RS256",
        Use: "sig",
    }

    // Create a sample JWT signed with your private key.
    jwt := createJwt(jwk, privateKey)
    fmt.Printf("1) You've just generated your first JWT:\n\n%s\n\n  You can investigate its payload by copying it to https://jwt.io.\n\n", jwt)

    // Expose your public key in a easy to digest way.
    jwkResponse, err := jwk.MarshalJSON()
    exitOnError(err, "failed marshal jwk into json")
    fmt.Printf("2) You should implement a JWKS endpoint (e.g. GET https://your-api.example.com/jwks) returing the following response:\n{\"keys\":[%s]}", string(jwkResponse))
}

func createJwt(jwk *jose.JSONWebKey, privateKey interface{}) string {
    signingKey := jose.SigningKey{Algorithm: jose.SignatureAlgorithm(jwk.Algorithm), Key: privateKey}
    signerOptions := jose.SignerOptions{ExtraHeaders: map[jose.HeaderKey]interface{}{
      "kid": jwk.KeyID,
      "typ": "JWT",
    }}
    signer, err := jose.NewSigner(signingKey, &signerOptions)
    exitOnError(err, "unable to make signer")

    payload := &TokenPayload {
        Jti: uuid.New().String(),
        Issuer: "your-app-id",
        Audience: "https://sso.sandbox.karhoo.com/oauth/v2/token-exchange",
        Subject: "38922b8b-21f5-469a-9942-31a858830d82",
        IssuedAt: time.Now().Unix(),
        ExpiresAt: time.Now().Unix() + 30*60,
        GivenName: "John",
        FamilyName: "Doe",
        Email: "john.doe@example.com",
        PhoneNumber: "+15005550006",
        Locale: "en",
    }
    payloadBytes, err := json.Marshal(payload)
    exitOnError(err, "unable to marshal token payload")

    obj, err := signer.Sign(payloadBytes)
    exitOnError(err, "unable to sign")

    jwt, err := obj.CompactSerialize()
    exitOnError(err, "unable to serialize jwt")

    return jwt
}

func readPublicKey(filePath string) (interface{}, string, error) {
    bytes, err := ioutil.ReadFile(filePath)
    if err != nil {
        return nil, "", err
    }

    block, _ := pem.Decode(bytes)
    if block == nil {
        return nil, "", fmt.Errorf("failed to decode PEM file %s", filePath)
    }

    cert, err := x509.ParsePKIXPublicKey(block.Bytes)
    if err != nil {
        return nil, "", fmt.Errorf("failed to parse certificate: %s", err)
    }

    hash := sha256.Sum256(block.Bytes)
    return cert, hex.EncodeToString(hash[:]), nil
}

func readPrivateKey(filePath string) (interface{}, error) {
    bytes, err := ioutil.ReadFile(filePath)
    if err != nil {
        return nil, err
    }

    block, _ := pem.Decode(bytes)
    if block == nil {
        return nil, fmt.Errorf("failed to decode PEM file %s", filePath)
    }

    privateKey, err := x509.ParsePKCS1PrivateKey(block.Bytes)
    if err != nil {
        return nil, fmt.Errorf("failed to parse certificate: %s", err)
    }

    return privateKey, nil
}

func exitOnError(err error, msg string) {
    if err != nil {
        fmt.Fprintf(os.Stderr, "%s: %s\n", msg, err)
        os.Exit(1)
    }
}
